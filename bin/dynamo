#!/usr/bin/env python

import sys
import os
import logging
import time
import re
import fnmatch

from common.inventory import InventoryManager
from common.transaction import TransactionManager
from common.demand import DemandManager
import common.interface.classes as classes
from detox.main import Detox
from detox.policy import Policy
from detox.partitioning import BelongsTo
import detox.configuration as detox_config
from dealer.main import Dealer
from dealer.policy import DealerPolicy
from common.dataformat import Site
import common.configuration as config

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Dynamo')
parser.add_argument('module', metavar = 'MODULE', nargs = '+', help = 'detox and/or dealer.')
parser.add_argument('--store', '-i', metavar = 'CLASS', dest = 'store_cls', default = '', help = 'Store backend class.')
parser.add_argument('--site-source', '-s', metavar = 'CLASS', dest = 'site_source_cls', default = '', help = 'SiteInfoSourceInterface class.')
parser.add_argument('--dataset-source', '-t', metavar = 'CLASS', dest = 'dataset_source_cls', default = '', help = 'DatasetInfoSourceInterface class.')
parser.add_argument('--replica-source', '-r', metavar = 'CLASS', dest = 'replica_source_cls', default = '', help = 'ReplicaInfoSourceInterface class.')
parser.add_argument('--access-history', '-a', metavar = 'CLASS', dest = 'access_history_cls', default = '', help = 'AccessHistoryInterface class.')
parser.add_argument('--lock', '-k', metavar = 'CLASS', dest = 'lock_cls', default = '', help = 'LockInterface class.')
parser.add_argument('--deletion', '-d', metavar = 'CLASS', dest = 'deletion_cls', default = '', help = 'DeletionInterface class.')
parser.add_argument('--copy', '-c', metavar = 'CLASS', dest = 'copy_cls', default = '', help = 'CopyInterface backend class.')
parser.add_argument('--force-inventory-update', '-I', action = 'store_true', dest = 'force_inventory_update', help = 'Force inventory to update.')
parser.add_argument('--detox-partition', '-p', metavar = 'PARTITIONS', dest = 'detox_partitions', nargs = '+', default = ['AnalysisOps', 'DataOps', 'RelVal'], help = 'Name of the detox partitions. Syntax is <partition>[:<definition name>]. Definition name is translated to path DYNAMO_BASE/policies/detox/<partition>.txt. If none is given, partition name is used.')
parser.add_argument('--comment', '-m', metavar = 'COMMENT', dest = 'comment', help = 'Comment to be sent to deletion interface as well as the local deletion record.')
parser.add_argument('--no-auto-approval', '-P', action = 'store_true', dest = 'no_auto_approval', help = 'Do not approve deletion and transfer requests automatically.')
parser.add_argument('--log-level', '-l', metavar = 'LEVEL', dest = 'log_level', default = 'WARNING', help = 'Logging level.')
parser.add_argument('--log-file', '-o', metavar = 'PATH', dest = 'log_file', default = '', help = 'Log output file.')
parser.add_argument('--dry-run', '-D', action = 'store_true', dest = 'dry_run', help = 'Do not make any actual deletion requests or changes to local databases.')
parser.add_argument('--test-run', '-T', action = 'store_true', dest = 'test_run', help = 'Make a test run (results recorded in local database).')

args = parser.parse_args()
sys.argv = []

if os.path.exists('/var/run/dynamod.pid'):
    with open('/var/run/dynamod.pid') as pidfile:
        if os.getppid() == int(pidfile.read()):
            config.daemon_mode = True

log_level = getattr(logging, args.log_level.upper())

if args.log_file:
    logging.basicConfig(filename = args.log_file, filemode = 'w', level = log_level)
else:
    logging.basicConfig(level = log_level)

if args.dry_run:
    config.read_only = True

elif not args.comment and not config.daemon_mode:
    print 'Non-dry run from command line requires a comment (-m).'
    sys.exit(1)

kwd = {}
for cls in ['store', 'site_source', 'dataset_source', 'replica_source']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

kwd['load_data'] = False

inventory_manager = InventoryManager(**kwd)

if args.force_inventory_update:
    inventory_manager.load(load_replicas = False)
else:
    inventory_manager.load(load_replicas = True)

kwd = {}
for cls in ['deletion', 'copy']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

transaction_manager = TransactionManager(**kwd)

kwd = {}
for cls in ['store', 'access_history', 'lock']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

demand_manager = DemandManager(**kwd)

history = classes.default_interface['history']()

with open(os.environ['DYNAMO_BASE'] + '/etc/policies.tag') as tag:
    policy_version = tag.read().strip()

if 'detox' in args.module:
    # Main detox object
    
    detox = Detox(inventory_manager, transaction_manager, demand_manager, history)
    
    # Set up detox policies
    
    detox_partitions = []
    
    for part_spec in args.detox_partitions:
        partdef = part_spec.split(':')

        part_name = partdef[0]
        if len(partdef) > 1:
            def_name = partdef[1]
        else:
            def_name = part_name
    
        def_path = os.environ['DYNAMO_BASE'] + '/policies/detox/' + def_name + '.txt'

        detox_partitions.append(Site.partitions[part_name])

        with open(def_path) as policy_def:    
            policy = Policy(partition, policy_def, policy_version, inventory_manager)
    
        detox.set_policy(policy)

if 'dealer' in args.module:
    # Main dealer object
    
    dealer = Dealer(inventory_manager, transaction_manager, demand_manager, history)

    group = inventory_manager.groups['AnalysisOps']

    policy = DealerPolicy(Site.partitions['AnalysisOps'], group = group, version = policy_version)
    
    dealer.set_policy(policy)


if args.force_inventory_update:
    inventory_manager.update()

if 'detox' in args.module:
    for partition in detox_partitions:
        detox.run(partition, is_test = args.test_run, comment = args.comment, auto_approval = not args.no_auto_approval)

if 'dealer' in args.module:
    dealer.run(Site.partitions['AnalysisOps'], is_test = args.test_run, comment = args.comment, auto_approval = not args.no_auto_approval)
